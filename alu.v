/*aul arthimact and logic operation...................(sel)
......................alu_res =a+b
****************************************************|4'b0000|
......................alu_res =a-b
****************************************************|4'b0001|
......................alu_res =a*b
****************************************************|4'b0010|
......................alu_res =a/b
****************************************************|4'b0011|
......................alu_res =a|b or gate 
****************************************************|4'b0100|
......................alu_res =a&b and gate 
**************************Eng/Eman Zidane **********|4'b0101|
......................alu_res =a^b xor gate 
****************************************************|4'b0110|
......................alu_res=~(a|b) nor_gate 
****************************************************|4'b0111|
......................alu_res = ~(a&b) nand gate 
****************************************************|4'b1000|
......................alu_res =~(a^b) noxr gate 
****************************************************|4'b1001|
......................alu_res =a>>3shift left 
****************************************************|4'b1010|
......................alu_res=a<<4 shift right 
****************************************************|4'b1001|
......................alu_res =b rotated left 3
****************************************************|4'b1100|
......................alu_res =a rotated right 2
****************************************************|4'b1101|
......................alu_res =a>b?1:0
****************************************************|4'b1110|
......................alu_res =a==b?1:0
****************************************************|4'b1111|

*/
module alu //(#parameter data_s=8)(#parameter sel_s=4 )
( input [7:0]  a, b, 
input [3:0] sel,// default as wires 
output [7:0]alu_out, output carry_out
);
reg [7:0] alu_res ;
wire [8:0]carr;
assign alu_out = alu_res ;
assign carr ={1'b0,a}+{1'b0,b};
assign carry_out = carr[8];
always @(*)//to aviod latchs
begin 
case(sel)
4'b0000:
alu_res =a+b;
4'b0001:
alu_res =a-b;
4'b0010:
alu_res =a*b;
4'b0011:
alu_res =a/b;
4'b0100:
alu_res =a|b ;
4'b0101:
alu_res =a&b;
4'b0110:
alu_res =a^b;
4'b0111:
alu_res=~(a|b);
4'b1000:
alu_res = ~(a&b);
4'b1001:
alu_res =~(a^b) ;
4'b1010:
alu_res =a>>3;
4'b1001:
alu_res=a<<4 ;
4'b1100:
alu_res={b[4:0],b[7:5]};
4'b1101:
alu_res ={a[3:0],a[7:4]};
4'b1110:
alu_res =(a>b)?8'b1:8'b0;
4'b1111:
alu_res =(a==b)?8'b1:8'b0;
default :alu_res =a|b ;
endcase
end 
endmodule 